{
    "cells": [
        {
            "cell_type": "markdown",
            "id": "1128eb6a",
            "metadata": {
                "id": "1128eb6a"
            },
            "source": [
                "# Problem Name"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "80f8bf3c",
            "metadata": {
                "id": "80f8bf3c"
            },
            "source": [
                "Multiparticle_dynamics_in_the_optical_tweezer_array"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "9e393f1a",
            "metadata": {
                "id": "9e393f1a"
            },
            "source": [
                "# Problem Id"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "302ddf1a",
            "metadata": {
                "id": "302ddf1a"
            },
            "source": [
                "32"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "90ca55d3",
            "metadata": {
                "id": "90ca55d3"
            },
            "source": [
                "# Problem Description Main"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "6f688bb6",
            "metadata": {
                "id": "6f688bb6"
            },
            "source": [
                "A system of $N$ identical nanospheres is trapped by an optical tweezer array that is arranged equidistantly along the $x$ axis. Each nanosphere is confined to oscillate near its equilibrium position due to the harmonic trapping forces from the linearly polarized optical tweezer array. The adjacent nanospheres interact via optical binding forces resulting from induced dipoles. The dynamics of phonon occupation are simulated for small oscillations along the $x$-axis near the equilibrium positions of each sphere, with the central difference method used for computing the derivatives in the simulation.\n",
                "\n"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "52acddb4",
            "metadata": {
                "id": "52acddb4"
            },
            "source": [
                "# Problem Background Main"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "b344a91c",
            "metadata": {
                "id": "b344a91c"
            },
            "source": [
                "In an optical tweezer array, trapped nanospheres experience optical binding forces due to interactions between their induced dipoles and external fields. These forces, combined with damping and vibrational couplings, govern the dynamics of phonon occupation. This problem explores these dynamics by modeling the system as coupled harmonic oscillators."
            ]
        },
        {
            "cell_type": "markdown",
            "id": "79b4eaa2",
            "metadata": {
                "id": "79b4eaa2"
            },
            "source": [
                "# Required Dependencies"
            ]
        },
        {
            "cell_type": "code",
            "source": [
                "import numpy as np\n",
                "from scipy.constants import epsilon_0, c\n",
                "from typing import List"
            ],
            "metadata": {
                "id": "rqb5P-scEPel"
            },
            "id": "rqb5P-scEPel",
            "execution_count": null,
            "outputs": []
        },
        {
            "cell_type": "markdown",
            "id": "649564c9",
            "metadata": {
                "id": "649564c9"
            },
            "source": [
                "# Problem Io"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "id": "dfdf4be2",
            "metadata": {
                "id": "dfdf4be2"
            },
            "outputs": [],
            "source": [
                "def solve_multiparticle_dynamics(N: int, t0: float, R: float, l: float, phi: float, Gamma: float, P: list[float], n0: list[float], w: float, a: float, n: float, h: float, rho: float, steps: int, L: np.ndarray = None, M: np.ndarray = None, gamma: np.ndarray = None) -> list[float]:\n",
                "\n",
                "    \"\"\"\n",
                "    Simulates phonon occupation dynamics in an optical tweezer array.\n",
                "\n",
                "    Args:\n",
                "        N (int): Number of nanospheres.\n",
                "        t0 (float): Time for simulation (seconds).\n",
                "        R (float): Distance between adjacent nanospheres (meters).\n",
                "        l (float): Wavelength of optical tweezers (meters).\n",
                "        phi (float): Polarization angle (radians).\n",
                "        Gamma (float): Damping coefficient for nanospheres.\n",
                "        P (list): Powers of optical tweezers (Watts).\n",
                "        n0 (list): Initial phonon occupation numbers.\n",
                "        w (float): Beam waist of optical tweezers (meters).\n",
                "        a (float): Radius of nanospheres (meters).\n",
                "        n (float): Refractive index of the nanospheres.\n",
                "        h (float): Step size for numerical derivative (meters).\n",
                "        rho (float): Density of nanospheres (kg/m\u00b3).\n",
                "        steps (int): Number of RK4 time steps.\n",
                "        L (np.ndarray, optional): Coupling matrix for the nanospheres.\n",
                "        M (np.ndarray, optional): Mass matrix for the nanospheres.\n",
                "        gamma (np.ndarray, optional): Interaction strength matrix for the system, representing additional inter-particle effects.\n",
                "\n",
                "    Returns:\n",
                "        list: Phonon occupation numbers at time t0.\n",
                "    \"\"\""
            ]
        },
        {
            "cell_type": "markdown",
            "id": "a82fa881",
            "metadata": {
                "id": "a82fa881"
            },
            "source": [
                "## Step Number"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "4f50d925",
            "metadata": {
                "id": "4f50d925"
            },
            "source": [
                "32.1"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "3e3c1612",
            "metadata": {
                "id": "3e3c1612"
            },
            "source": [
                "## Step Name"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "34029bcf",
            "metadata": {
                "id": "34029bcf"
            },
            "source": [
                "Calculate Optical Binding Force"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "52c241d1",
            "metadata": {
                "id": "52c241d1"
            },
            "source": [
                "## Step Description Prompt"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "90a3173b",
            "metadata": {
                "id": "90a3173b"
            },
            "source": [
                "Two linearly polarized optical traps having the same polarization direction are separated by a distance $R$. Implement a Python function to compute the optical binding force between the two identical nanospheres trapped by a linearly polarized optical tweezer array. The function should calculate the induced dipole interactions between the two nanospheres, assuming the Rayleigh approximation."
            ]
        },
        {
            "cell_type": "markdown",
            "id": "ac119de8",
            "metadata": {
                "id": "ac119de8"
            },
            "source": [
                "## Step Background"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "6eaed3ac",
            "metadata": {
                "id": "6eaed3ac"
            },
            "source": [
                "If we suppose the nanospheres are placed on the $x$-axis while each nanosphere is trapped by a linearly polarized laser beam propagating along the $z$-axis, we have the induced dipole moments as $\\mathbf{p}_1 = \\alpha \\mathbf{E}_1$ and $\\mathbf{p}_2 = \\alpha \\mathbf{E}_2$, where $\\alpha = 4\\pi \\varepsilon_0 a^3 \\frac{n^2 - 1}{n^2 + 2}$ is the scalar polarizability of the nanospheres. The trapping electric field $E_i$ is related to the laser power $P_i$ by:\n",
                "\n",
                "\\begin{equation}\n",
                "E_i = \\sqrt{\\frac{4P_i}{\\pi w^2 \\varepsilon_0 c}},\n",
                "\\end{equation}\n",
                "\n",
                "where $E_i$ is the amplitude of the electric field at the location of the $i$-th nanosphere, $P_i$ is the power of the optical tweezers trapping the $i$-th nanosphere, $w$ is the beam waist of the optical tweezers (the radial size of the laser beam at the focal point), $\\varepsilon_0$ is the permittivity of free space, and $c$ is the speed of light in vacuum.\n",
                "\n",
                "The electric field emitted by dipole 2 at the location of dipole 1 can be written as:\n",
                "\\begin{equation}\n",
                "\\mathbf{E}_{\\mathrm{ind},2}(\\mathbf{r}_1) = \\mathbf{G}(\\mathbf{R}) \\cdot \\mathbf{p}_2,\n",
                "\\end{equation}\n",
                "where $\\mathbf{G}(\\mathbf{R})$ is the dyadic Green's function. The dyadic Green\u2019s function represents the relationship between the source field generated by a dipole and the resultant field at a different spatial point, incorporating both near-field and far-field effects. Its derivation involves solving Maxwell\u2019s equations for a dipole source in free space. Specifically,  $G_{pq}$  accounts for the propagation of the electromagnetic field emitted by dipole 2 to the position of dipole 1 and is expressed as:\n",
                "\n",
                "\\begin{equation}\n",
                "G_{pq} = \\frac{\\exp(ikR)}{4\\pi \\varepsilon_0 R^3} \\left[ \\left(3 - 3ikR - k^2R^2\\right) \\frac{R_p R_q}{R^2} + \\left(k^2R^2 + ikR - 1\\right) \\delta_{pq} \\right].\n",
                "\\end{equation}\n",
                "\n",
                "Here, $R = |\\mathbf{R}|$ is the distance between the two dipoles, $\\mathbf{R} = \\mathbf{r}_1 - \\mathbf{r}_2$ is the vector pointing from dipole 2 to dipole 1, $k = 2\\pi / \\lambda$ is the wavevector corresponding to the wavelength $\\lambda$ of the optical tweezers, and $\\delta_{pq}$ is the Kronecker delta.\n",
                "\n",
                "The derivation of $\\mathbf{G}(\\mathbf{R})$ begins with solving the Helmholtz equation for the Green\u2019s function $G(\\mathbf{r}, \\mathbf{r}')$, which satisfies:\n",
                "\\begin{equation}\n",
                "\\nabla \\times \\nabla \\times \\mathbf{G}(\\mathbf{R}) - k^2 \\mathbf{G}(\\mathbf{R}) = \\delta(\\mathbf{R}) \\mathbf{I},\n",
                "\\end{equation}\n",
                "where $\\mathbf{I}$ is the identity tensor. Using spherical wave expansions and far-field approximations, the above equation yields the expression for $\\mathbf{G}(\\mathbf{R})$ presented earlier. The term $\\frac{\\exp(ikR)}{R^3}$ captures the spatial dependence of the field in the Rayleigh approximation, with $R^3$ arising from the near-field interaction, while $\\exp(ikR)$ accounts for phase effects in the radiative and reactive fields. The two main components inside the brackets correspond to the longitudinal and transverse field contributions, influenced by the symmetry of the dipole interaction.\n",
                "\n",
                "The optical binding force along the $x$-axis is derived as:\n",
                "\\begin{equation}\n",
                "F_x = \\frac{1}{2} \\operatorname{Re} \\left[ \\mathbf{p}_1 \\cdot \\nabla_x (\\mathbf{E}_{\\mathrm{ind},2}(\\mathbf{r}_1)) \\right].\n",
                "\\end{equation}\n",
                "\n",
                "The derived radial optical binding force $F_x$ can be expressed as:\n",
                "\\begin{equation}\n",
                "F_x = F_{xx} + F_{xy},\n",
                "\\end{equation}\n",
                "where:\n",
                "\\begin{equation}\n",
                "F_{xx} = \\frac{2 \\alpha^2 E_{x1} E_{x2}}{8\\pi \\varepsilon_0 R^4} \\left[ -3 \\cos(kR) - 3kR \\sin(kR) + (kR)^2 \\cos(kR) \\right],\n",
                "\\end{equation}\n",
                "\\begin{equation}\n",
                "F_{xy} = \\frac{\\alpha^2 E_{y1} E_{y2}}{8\\pi \\varepsilon_0 R^4} \\left[ 3 \\cos(kR) + 3kR \\sin(kR) - 2(kR)^2 \\cos(kR) - (kR)^3 \\sin(kR) \\right].\n",
                "\\end{equation}\n",
                "\n",
                "The Rayleigh approximation assumes that each nanosphere acts as an induced dipole in the external field. The optical binding force arises from the interaction between the dipole induced in one nanosphere and the electric field generated by the induced dipole of the other nanosphere. This force depends on factors such as polarization, inter-sphere distance $R$, and beam parameters."
            ]
        },
        {
            "cell_type": "markdown",
            "id": "cb4ca6e0",
            "metadata": {
                "id": "cb4ca6e0"
            },
            "source": [
                "## Function Header"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 218,
            "id": "9f7a2672",
            "metadata": {
                "id": "9f7a2672"
            },
            "outputs": [],
            "source": [
                "import numpy as np\n",
                "from scipy.constants import epsilon_0, c\n",
                "from typing import List\n",
                "\n",
                "def calculate_binding_force(P: list[float], phi: float, R: float, l: float, w: float, a: float, n: float) -> float:\n",
                "    \"\"\"\n",
                "    Function to calculate the optical binding force between two trapped nanospheres.\n",
                "\n",
                "    Args:\n",
                "        P (list of float): Laser powers for the two nanospheres (Watts).\n",
                "        phi (float): Polarization angle of the tweezers (radians).\n",
                "        R (float): Distance between adjacent nanospheres (meters).\n",
                "        l (float): Wavelength of the optical tweezers (meters).\n",
                "        w (float): Beam waist of the optical tweezers (meters).\n",
                "        a (float): Radius of the nanospheres (meters).\n",
                "        n (float): Refractive index of the nanospheres.\n",
                "\n",
                "    Returns:\n",
                "        float: Optical binding force (Newtons).\n",
                "    \"\"\""
            ]
        },
        {
            "cell_type": "markdown",
            "id": "f3de92ba",
            "metadata": {
                "id": "f3de92ba"
            },
            "source": [
                "## Ground Truth Code"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 216,
            "id": "e1c9ad87",
            "metadata": {
                "id": "e1c9ad87"
            },
            "outputs": [],
            "source": [
                "import numpy as np\n",
                "from scipy.constants import epsilon_0, c\n",
                "from typing import List\n",
                "\n",
                "def calculate_binding_force(P: list[float], phi: float, R: float, l: float, w: float, a: float, n: float) -> float:\n",
                "    \"\"\"\n",
                "    Function to calculate the optical binding force between two trapped nanospheres.\n",
                "\n",
                "    Args:\n",
                "        P (list of float): Laser powers for the two nanospheres (Watts).\n",
                "        phi (float): Polarization angle of the tweezers (radians).\n",
                "        R (float): Distance between adjacent nanospheres (meters).\n",
                "        l (float): Wavelength of the optical tweezers (meters).\n",
                "        w (float): Beam waist of the optical tweezers (meters).\n",
                "        a (float): Radius of the nanospheres (meters).\n",
                "        n (float): Refractive index of the nanospheres.\n",
                "\n",
                "    Returns:\n",
                "        float: Optical binding force (Newtons).\n",
                "    \"\"\"\n",
                "    # Wave number\n",
                "    k = 2 * np.pi / l\n",
                "    # Scalar polarizability\n",
                "    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)\n",
                "    # Electric fields\n",
                "    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n",
                "    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n",
                "    # Forces\n",
                "    Fxx = (\n",
                "        2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n",
                "        * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n",
                "    )\n",
                "    Fxy = (\n",
                "        alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n",
                "        * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R))\n",
                "    )\n",
                "    return (Fxx + Fxy) * 1e12"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "8f90ae59",
            "metadata": {
                "id": "8f90ae59"
            },
            "source": [
                "## Test Cases"
            ]
        },
        {
            "cell_type": "code",
            "source": [
                "# 32.1 # Test case 1\n",
                "P = [10000000, 100000000]\n",
                "phi = 0\n",
                "R = 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "target = 2.090553478330249e-6 * 1e12  # picoNewtons\n",
                "result = calculate_binding_force(P, phi, R, l, w, a, n)\n",
                "#print(f\"Test 1 - phi = {phi}: Result = {result}, Target = {target}\")\n",
                "assert np.allclose(result, target, rtol=1e-5, atol=1e-8), f\"Result {result} does not match target {target}\"\n",
                "\n",
                "# Test case 2\n",
                "P = [10000000, 100000000]\n",
                "phi = np.pi/2\n",
                "R = 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "target = -2.17651746535146e-06 * 1e12  # picoNewtons\n",
                "result = calculate_binding_force(P, phi, R, l, w, a, n)\n",
                "#print(f\"Test 2 - phi = {phi}: Result = {result}, Target = {target}\")\n",
                "assert np.allclose(result, target, rtol=1e-5, atol=1e-8), f\"Result {result} does not match target {target}\"\n",
                "\n",
                "# Test case 3\n",
                "P = [1000000000, 1000000000]\n",
                "phi = np.pi/4\n",
                "R = 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "target = -1.3592099786808985e-06 * 1e12  # picoNewtons\n",
                "result = calculate_binding_force(P, phi, R, l, w, a, n)\n",
                "#print(f\"Test 3 - phi = {phi}: Result = {result}, Target = {target}\")\n",
                "assert np.allclose(result, target, rtol=1e-5, atol=1e-8), f\"Result {result} does not match target {target}\"\n"
            ],
            "metadata": {
                "id": "0OzDncSaF9QX"
            },
            "id": "0OzDncSaF9QX",
            "execution_count": 217,
            "outputs": []
        },
        {
            "cell_type": "markdown",
            "id": "6034de13",
            "metadata": {
                "id": "6034de13"
            },
            "source": [
                "## Return Line"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "932fdbb1",
            "metadata": {
                "id": "932fdbb1"
            },
            "source": []
        },
        {
            "cell_type": "markdown",
            "id": "9e374e04",
            "metadata": {
                "id": "9e374e04"
            },
            "source": [
                "## Step Number"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "63693ba9",
            "metadata": {
                "id": "63693ba9"
            },
            "source": [
                "32.2"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "e6cea857",
            "metadata": {
                "id": "e6cea857"
            },
            "source": [
                "## Step Name"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "c05ed2f8",
            "metadata": {
                "id": "c05ed2f8"
            },
            "source": [
                "Generate Hamiltonian"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "b6bffe95",
            "metadata": {
                "id": "b6bffe95"
            },
            "source": [
                "## Step Description Prompt"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "23952c98",
            "metadata": {
                "id": "23952c98"
            },
            "source": [
                "Develop a Python function to compute the Hamiltonian for the provided nanospherical system, considering the damping coefficient array and the linearized optical binding force acting upon the trapped nanospheres.\n",
                "\n",
                "The Hamiltonian for the system is given by:\n",
                "\n",
                "$$H = \\sum_i \\hbar \\Omega_i b_i^{\\dagger} b_i + \\hbar \\sum_{i \\neq j} g_{i j} \\left( b_i^{\\dagger} b_j + b_i b_j^{\\dagger} \\right),$$\n",
                "\n",
                "where $b_i$ and $b_i^{\\dagger}$ are the annihilation and creation operators, respectively. These operators allow the Hamiltonian to be expressed in the quantized form in the basis of their outer products. The resonant frequencies $\\Omega_i$ of the nanospheres are modified to include the effects of damping, and the coupling constants $g_{i j}$ are derived from the linearized optical binding forces.\n",
                "\n",
                "This function will account for:\n",
                "\n",
                "- The damping coefficients $\\Gamma_i$, which modify the resonant frequencies.\n",
                "- The pairwise optical binding forces $k_{i j}$, which determine the coupling constants $g_{i j}$.\n",
                "- The contribution of the local optical tweezer forces $k_i$, which define the intrinsic stiffness for each nanosphere.\n",
                "\n",
                "The resulting Hamiltonian matrix will reflect the quantized dynamics of the system, incorporating resonant frequencies, coupling constants, and damping corrections."
            ]
        },
        {
            "cell_type": "markdown",
            "id": "90498115",
            "metadata": {
                "id": "90498115"
            },
            "source": [
                "## Step Background"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "ac821bb3",
            "metadata": {
                "id": "ac821bb3"
            },
            "source": [
                "Around the equilibrium position, the optical binding force between nanospheres is linearized as:\n",
                "\n",
                "$$\n",
                "\\Delta F_{ij} = \\left. \\Delta R \\frac{dF_x}{dR} \\right|_{x = |i - j|d} \\equiv k_{ij} \\Delta R,\n",
                "$$\n",
                "\n",
                "where:\n",
                "- $ \\Delta F_{ij} $: Perturbation in the optical binding force between the $ i $-th and $ j $-th nanospheres,\n",
                "- $ \\Delta R $: Displacement from the equilibrium position,\n",
                "- $ d $: Distance between adjacent nanospheres in the array.\n",
                "\n",
                "The linearized dynamics for the $ i $-th nanosphere, including damping effects, are written as:\n",
                "\n",
                "$$\n",
                "m \\ddot{x}_i + \\Gamma_i \\dot{x}_i + k_i x_i + \\sum_{j \\ne i} k_{ij} (x_i - x_j) = 0,\n",
                "$$\n",
                "\n",
                "where:\n",
                "- $ m $: Mass of the nanosphere,\n",
                "- $ \\Gamma_i $: Damping coefficient for the $ i $-th nanosphere, incorporating effects like Stokes drag or other dissipative forces,\n",
                "- $ k_i $: Stiffness of the optical trap confining the $ i $-th nanosphere,\n",
                "- $ k_{ij} $: Pairwise interaction strength between the $ i $-th and $ j $-th nanospheres.\n",
                "\n",
                "The inclusion of $ \\Gamma_i $ explicitly accounts for dissipative processes such as fluid drag or active damping corrections. This ensures the model reflects both the conservative optical trapping forces and dissipative effects.\n",
                "\n",
                "The corresponding classical Hamiltonian for the system is given by:\n",
                "\n",
                "$$\n",
                "H = \\sum_i \\left( \\frac{p_i^2}{2m} + \\frac{1}{2} k_i x_i^2 \\right) + \\sum_{i \\ne j} \\frac{1}{2} k_{ij} (x_i - x_j)^2.\n",
                "$$\n",
                "\n",
                "To quantize the Hamiltonian, we replace the classical position $ x_i $ and momentum $ p_i $ operators with their quantum counterparts. In terms of ladder operators $ b_i $ and $ b_i^\\dagger $, the quantum position and momentum operators are expressed as:\n",
                "\n",
                "$$\n",
                "x_i = \\sqrt{\\frac{\\hbar}{2 m \\Omega_i}} \\left(b_i + b_i^\\dagger \\right), \\quad p_i = i \\sqrt{\\frac{\\hbar m \\Omega_i}{2}} \\left(b_i^\\dagger - b_i \\right).\n",
                "$$\n",
                "\n",
                "Substituting these into the classical Hamiltonian, the quadratic terms in $ x_i^2 $ and $ p_i^2 $ simplify, yielding the quantized Hamiltonian:\n",
                "\n",
                "$$\n",
                "H = \\sum_i \\hbar \\Omega_i \\left(b_i^\\dagger b_i + \\frac{1}{2} \\right) + \\hbar \\sum_{i \\neq j} g_{ij} \\left(b_i^\\dagger b_j + b_i b_j^\\dagger\\right).\n",
                "$$\n",
                "\n",
                "The coupling constant $ g_{ij} $ arises from the pairwise interaction term $ \\frac{1}{2} k_{ij} (x_i - x_j)^2 $, and is defined as:\n",
                "\n",
                "$$\n",
                "g_{ij} = -\\frac{k_{ij}}{2 m \\sqrt{\\Omega_i \\Omega_j}}.\n",
                "$$\n",
                "\n",
                "For convenience, we neglect the zero-point energy (constant term) in the summation, resulting in the simplified quantized Hamiltonian:\n",
                "\n",
                "$$\n",
                "H = \\sum_i \\hbar \\Omega_i b_i^\\dagger b_i + \\hbar \\sum_{i \\neq j} g_{ij} \\left(b_i^\\dagger b_j + b_i b_j^\\dagger\\right).\n",
                "$$\n",
                "\n",
                "Here:\n",
                "- $ \\Omega_i = \\sqrt{\\frac{k_i + \\Gamma_i + \\sum_{j \\neq i} k_{ij}}{m}} $\n",
                "  is the resonant frequency, modified to include damping and interaction effects.\n",
                "- $ g_{ij} = -\\frac{k_{ij}}{2 m \\sqrt{\\Omega_i \\Omega_j}} $\n",
                "  is the coupling constant.\n",
                "\n",
                "This Hamiltonian can be expressed in matrix form as $ H_{ii}= \\Omega_i $ and $ H_{ij} = g_{ij} $. The Hamiltonian represents the coupled quantum oscillatory system, incorporating resonant frequencies, coupling constants, and damping coefficients between nanospheres. These parameters are derived from linearized binding forces and include the influence of both the trapping stiffness and the damping terms in the effective spring constants.\n"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "d798e244",
            "metadata": {
                "id": "d798e244"
            },
            "source": [
                "## Function Header"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 230,
            "id": "403b7f1c",
            "metadata": {
                "id": "403b7f1c"
            },
            "outputs": [],
            "source": [
                "def generate_hamiltonian(P: list[float], phi: float, R: float, l: float, w: float, a: float,\n",
                "                         n: float, N: int, rho: float, k_ij: np.ndarray, gamma: np.ndarray) -> np.ndarray:\n",
                "    \"\"\"\n",
                "    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n",
                "\n",
                "    Args:\n",
                "        P (list[float]): List of laser powers for each nanosphere (Watts)\n",
                "        phi (float): Polarization angle (radians)\n",
                "        R (float): Distance between adjacent nanospheres (meters)\n",
                "        l (float): Wavelength of optical tweezers (meters)\n",
                "        w (float): Beam waist of optical tweezers (meters)\n",
                "        a (float): Radius of nanospheres (meters)\n",
                "        n (float): Refractive index of nanospheres\n",
                "        N (int): Number of nanospheres\n",
                "        rho (float): Density of nanospheres (kg/m\u00b3)\n",
                "        k_ij (np.ndarray): Pairwise binding forces (N)\n",
                "        gamma (np.ndarray): Damping coefficients for each nanosphere\n",
                "\n",
                "    Returns:\n",
                "        np.ndarray: NxN Hamiltonian matrix\n",
                "    \"\"\""
            ]
        },
        {
            "cell_type": "markdown",
            "id": "ec4ada18",
            "metadata": {
                "id": "ec4ada18"
            },
            "source": [
                "## Ground Truth Code"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 228,
            "id": "6d5b7690",
            "metadata": {
                "id": "6d5b7690"
            },
            "outputs": [],
            "source": [
                "def generate_hamiltonian(P: list[float], phi: float, R: float, l: float, w: float, a: float,\n",
                "                         n: float, N: int, rho: float, k_ij: np.ndarray, gamma: np.ndarray) -> np.ndarray:\n",
                "    \"\"\"\n",
                "    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n",
                "\n",
                "    Args:\n",
                "        P (list[float]): List of laser powers for each nanosphere (Watts)\n",
                "        phi (float): Polarization angle (radians)\n",
                "        R (float): Distance between adjacent nanospheres (meters)\n",
                "        l (float): Wavelength of optical tweezers (meters)\n",
                "        w (float): Beam waist of optical tweezers (meters)\n",
                "        a (float): Radius of nanospheres (meters)\n",
                "        n (float): Refractive index of nanospheres\n",
                "        N (int): Number of nanospheres\n",
                "        rho (float): Density of nanospheres (kg/m\u00b3)\n",
                "        k_ij (np.ndarray): Pairwise binding forces (N)\n",
                "        gamma (np.ndarray): Damping coefficients for each nanosphere\n",
                "\n",
                "    Returns:\n",
                "        np.ndarray: NxN Hamiltonian matrix\n",
                "    \"\"\"\n",
                "    # Mass, polarizability, initial k_i\n",
                "    m: float = (4/3) * np.pi * (a**3) * rho\n",
                "    alpha: float = 4 * np.pi * epsilon_0 * a**3 * ((n**2 - 1)/(n**2 + 2))\n",
                "    k_i: np.ndarray = np.array([(8 * alpha * p)/(np.pi * w**4 * epsilon_0 * c) for p in P])\n",
                "\n",
                "    # Resonant frequencies\n",
                "    Omega: np.ndarray = np.zeros(N)\n",
                "    for i in range(N):\n",
                "        k_eff = k_i[i] + gamma[i] + np.sum(k_ij[i, :])\n",
                "        if k_eff < 0:\n",
                "            print(f\"Warning: Negative effective spring constant for particle {i}. Clamping to zero.\")\n",
                "            k_eff = 0\n",
                "        Omega[i] = np.sqrt(k_eff / m) if k_eff > 0 else 0\n",
                "\n",
                "    # Hamiltonian matrix\n",
                "    H: np.ndarray = np.zeros((N, N))\n",
                "    np.fill_diagonal(H, Omega)\n",
                "    for i in range(N):\n",
                "        for j in range(i + 1, N):\n",
                "            if Omega[i] > 0 and Omega[j] > 0:\n",
                "                g_ij: float = -k_ij[i, j] / (2 * m * np.sqrt(Omega[i] * Omega[j]))\n",
                "                H[i, j] = H[j, i] = g_ij\n",
                "    return H\n"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "3c7ac737",
            "metadata": {
                "id": "3c7ac737"
            },
            "source": [
                "## Test Cases"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": 229,
            "id": "69c6d6ce",
            "metadata": {
                "id": "69c6d6ce"
            },
            "outputs": [],
            "source": [
                "# Test case 1\n",
                "P = [50e-3, 50e-3, 50e-3, 50e-3, 50e-3]\n",
                "gamma = np.array([1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9])\n",
                "phi = np.pi / 2\n",
                "R = 0.99593306197 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-8\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "k_ij = np.array([\n",
                "    [0.0, -7.681379869134715e-08, -4.4198493243744006e-08, -3.01656306194563e-08, -2.277029857871201e-08],\n",
                "    [-7.681379869134715e-08, 0.0, -7.681379869134715e-08, -4.4198493243744006e-08, -3.01656306194563e-08],\n",
                "    [-4.4198493243744006e-08, -7.681379869134715e-08, 0.0, -7.681379869134715e-08, -4.4198493243744006e-08],\n",
                "    [-3.01656306194563e-08, -4.4198493243744006e-08, -7.681379869134715e-08, 0.0, -7.681379869134715e-08],\n",
                "    [-2.277029857871201e-08, -3.01656306194563e-08, -4.4198493243744006e-08, -7.681379869134715e-08, 0.0]])\n",
                "\n",
                "target = [\n",
                "    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n",
                "    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176],\n",
                "    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n",
                "    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n",
                "    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n",
                "]\n",
                "\n",
                "output = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\n",
                "#print(\"Expected target Hamiltonian matrix:\\n\", np.array(target))\n",
                "#print(\"Generated Hamiltonian matrix:\\n\", output)\n",
                "assert np.allclose(output, target, rtol=1e-3)\n",
                "\n",
                "# 32.2 - Test Case 2\n",
                "P = [50e-3, 50e-3, 50e-3, 50e-3, 50e-3]\n",
                "gamma = np.array([1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9])\n",
                "phi = np.pi / 2\n",
                "R = 2 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-8\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "k_ij = np.array([\n",
                "    [0.0, -4.354835487054123e-08, -2.252061426059221e-08, -1.5106793817536392e-08, -1.1354570981112845e-08],\n",
                "    [-4.354835487054123e-08, 0.0, -4.354835487054123e-08, -2.252061426059221e-08, -1.5106793817536392e-08],\n",
                "    [-2.252061426059221e-08, -4.354835487054123e-08, 0.0, -4.354835487054123e-08, -2.252061426059221e-08],\n",
                "    [-1.5106793817536392e-08, -2.252061426059221e-08, -4.354835487054123e-08, 0.0, -4.354835487054123e-08],\n",
                "    [-1.1354570981112845e-08, -1.5106793817536392e-08, -2.252061426059221e-08, -4.354835487054123e-08, 0.0]])\n",
                "\n",
                "target = [\n",
                "    [9.88866250e+05, 1.98714355e+03, 1.02782631e+03, 6.89348389e+02, 5.17743766e+02],\n",
                "    [1.98714355e+03, 9.87397235e+05, 1.98896227e+03, 1.02841422e+03, 6.89348389e+02],\n",
                "    [1.02782631e+03, 1.98896227e+03, 9.87058624e+05, 1.98896227e+03, 1.02782631e+03],\n",
                "    [6.89348389e+02, 1.02841422e+03, 1.98896227e+03, 9.87397235e+05, 1.98714355e+03],\n",
                "    [5.17743766e+02, 6.89348389e+02, 1.02782631e+03, 1.98714355e+03, 9.88866250e+05]\n",
                "]\n",
                "output = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\n",
                "assert np.allclose(output, target, rtol=1e-3)\n",
                "\n",
                "# 32.2 - Test Case 3\n",
                "P = [50e-3, 50e-3, 50e-3, 50e-3, 50e-3]\n",
                "gamma = np.array([1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9, 1.88e-9])\n",
                "phi = 0\n",
                "R = 1 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-8\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "k_ij = np.array([\n",
                "    [0.0, -2.166999226554586e-08, -2.839815457291363e-09, -8.4861704309071e-10, -3.5907195757129063e-10],\n",
                "    [-2.166999226554586e-08, 0.0, -2.166999226554586e-08, -2.839815457291363e-09, -8.4861704309071e-10],\n",
                "    [-2.839815457291363e-09, -2.166999226554586e-08, 0.0, -2.166999226554586e-08, -2.839815457291363e-09],\n",
                "    [-8.4861704309071e-10, -2.839815457291363e-09, -2.166999226554586e-08, 0.0, -2.166999226554586e-08],\n",
                "    [-3.5907195757129063e-10, -8.4861704309071e-10, -2.839815457291363e-09, -2.166999226554586e-08, 0.0]])\n",
                "\n",
                "\n",
                "target = [\n",
                "    [9.91907992e+05, 9.85573690e+02, 1.29183297e+02, 3.86029400e+01, 1.63260875e+01],\n",
                "    [9.85573690e+02, 9.90938753e+05, 9.86100660e+02, 1.29240548e+02, 3.86029400e+01],\n",
                "    [1.29183297e+02, 9.86100660e+02, 9.90848130e+05, 9.86100660e+02, 1.29183297e+02],\n",
                "    [3.86029400e+01, 1.29240548e+02, 9.86100660e+02, 9.90938753e+05, 9.85573690e+02],\n",
                "    [1.63260875e+01, 3.86029400e+01, 1.29183297e+02, 9.85573690e+02, 9.91907992e+05]\n",
                "]\n",
                "output = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\n",
                "assert np.allclose(output, target, rtol=1e-3)"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "706bb611",
            "metadata": {
                "id": "706bb611"
            },
            "source": [
                "## Return Line"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "bf9c121d",
            "metadata": {
                "id": "bf9c121d"
            },
            "source": [
                "## Step Number"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "a1bed302",
            "metadata": {
                "id": "a1bed302"
            },
            "source": [
                "32.3"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "cbf7499a",
            "metadata": {
                "id": "cbf7499a"
            },
            "source": [
                "## Step Name"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "62cae348",
            "metadata": {
                "id": "62cae348"
            },
            "source": [
                "Runge-Kutta for Phonon Dynamics"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "a8e02116",
            "metadata": {
                "id": "a8e02116"
            },
            "source": [
                "## Step Description Prompt"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "d215627d",
            "metadata": {
                "id": "d215627d"
            },
            "source": [
                "Write a Python function to implement the fourth-order Runge-Kutta (RK4) method to simulate phonon occupation dynamics of the trapped nanosphere system. The dynamics are governed by the Lindblad master equation for the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \\rangle$, where the Hamiltonian $H$ is represented in the basis of the outer products of the ladder operators $b_i^\\dagger b_j$, and includes a factor of $\\hbar$ (i.e., $H = \\hbar \\tilde{H}$). The Lindblad master equation is expressed as:\n",
                "\n",
                "$$\\dot{C} = \\frac{i}{\\hbar}[H, C] + \\{L, C\\} + M.$$\n",
                "\n",
                "Here, $H$ describes the coherent dynamics, $L$ represents dissipation, and $M$ accounts for thermal effects. The RK4 method should be used to numerically solve this equation.\n"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "916764c9",
            "metadata": {
                "id": "916764c9"
            },
            "source": [
                "## Step Background"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "1c2d6744",
            "metadata": {
                "id": "1c2d6744"
            },
            "source": [
                "The Lindblad master equation governs the evolution of the correlation matrix $C_{ij} = \\langle b_i^\\dagger b_j \\rangle$, which describes the dynamics of an open quantum system. The correlation matrix $C$ is derived from the density matrix $\\rho$ by relating the expectation of the operators $b_i^\\dagger b_j$ as $\\langle b_i^\\dagger b_j \\rangle = \\operatorname{tr}(\\rho b_i^\\dagger b_j)$. For the Lindblad equation, the Hamiltonian $H$ is expressed in the basis of the outer products of the ladder operators $b_i^\\dagger b_j$, and it is scaled by $\\hbar$ (i.e., $H = \\hbar \\tilde{H}$). The Lindblad master equation is given by:\n",
                "\n",
                "$$\\dot{C} = \\frac{i}{\\hbar}[H, C] + \\{L, C\\} + M,$$\n",
                "\n",
                "where:\n",
                "\n",
                "- $H$ is the system Hamiltonian, which determines coherent dynamics,\n",
                "- $L = -\\frac{1}{2} \\operatorname{Diag}(\\Gamma_1, \\Gamma_2, \\ldots, \\Gamma_N)$ is the dissipation matrix describing loss rates, and\n",
                "- $M = \\operatorname{Diag}(\\Gamma_1 n_1^{\\text{th}}, \\Gamma_2 n_2^{\\text{th}}, \\ldots, \\Gamma_N n_N^{\\text{th}})$ is the reservoir matrix describing thermal effects.\n",
                "\n",
                "The standard Fourth-Order Runge-Kutta (RK4) method is used to numerically solve this equation. At each time step $n$, the next state $C_{n+1}$ is computed as:\n",
                "\n",
                "$$C_{n+1} = C_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4),$$\n",
                "\n",
                "where:\n",
                "\n",
                "$$k_1 = \\frac{i}{\\hbar}[H, C_n] + \\{L, C_n\\} + M,$$\n",
                "$$k_2 = \\frac{i}{\\hbar}[H, C_n + \\frac{1}{2}k_1 \\Delta t] + \\{L, C_n + \\frac{1}{2}k_1 \\Delta t\\} + M,$$\n",
                "$$k_3 = \\frac{i}{\\hbar}[H, C_n + \\frac{1}{2}k_2 \\Delta t] + \\{L, C_n + \\frac{1}{2}k_2 \\Delta t\\} + M,$$\n",
                "$$k_4 = \\frac{i}{\\hbar}[H, C_n + k_3 \\Delta t] + \\{L, C_n + k_3 \\Delta t\\} + M.$$\n",
                "\n",
                "The RK4 method provides a robust way to integrate the Lindblad equation, ensuring stability and accuracy in capturing the system's evolution under dissipation and external fields.\n"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "e362c233",
            "metadata": {
                "id": "e362c233"
            },
            "source": [
                "## Function Header"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "id": "25a4f9a5",
            "metadata": {
                "id": "25a4f9a5"
            },
            "outputs": [],
            "source": [
                "import numpy as np # include all of the relevant imports in your ground truth code\n",
                "from scipy.constants import epsilon_0, c\n",
                "from typing import List\n",
                "\n",
                "def runge_kutta_dynamics(C0: np.ndarray, H: np.ndarray, L: np.ndarray, M: np.ndarray, t0: float, steps: int) -> np.ndarray:\n",
                "    \"\"\"\n",
                "    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n",
                "\n",
                "    Args:\n",
                "        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n",
                "        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n",
                "        L (numpy.ndarray): Dissipation matrix (real diagonal).\n",
                "        M (numpy.ndarray): Reservoir matrix (real diagonal).\n",
                "        t0 (float): Total simulation time (seconds).\n",
                "        steps (int): Number of RK4 time steps.\n",
                "\n",
                "    Returns:\n",
                "        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n",
                "    \"\"\""
            ]
        },
        {
            "cell_type": "markdown",
            "id": "67ccfdb7",
            "metadata": {
                "id": "67ccfdb7"
            },
            "source": [
                "## Ground Truth Code"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "id": "029b97f5",
            "metadata": {
                "id": "029b97f5"
            },
            "outputs": [],
            "source": [
                "import numpy as np # include all of the relevant imports in your ground truth code\n",
                "from scipy.constants import epsilon_0, c\n",
                "from typing import List\n",
                "\n",
                "def runge_kutta_dynamics(C0: np.ndarray, H: np.ndarray, L: np.ndarray, M: np.ndarray, t0: float, steps: int) -> np.ndarray:\n",
                "    \"\"\"\n",
                "    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n",
                "\n",
                "    Args:\n",
                "        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n",
                "        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n",
                "        L (numpy.ndarray): Dissipation matrix (real diagonal).\n",
                "        M (numpy.ndarray): Reservoir matrix (real diagonal).\n",
                "        t0 (float): Total simulation time (seconds).\n",
                "        steps (int): Number of RK4 time steps.\n",
                "\n",
                "    Returns:\n",
                "        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n",
                "    \"\"\"\n",
                "    delta_t = t0 / steps\n",
                "    C = np.array(C0, dtype=np.complex128)\n",
                "\n",
                "    def commutator(A, B) -> np.ndarray:\n",
                "        return np.dot(A, B) - np.dot(B, A)\n",
                "\n",
                "    def anticommutator(A, B) -> np.ndarray:\n",
                "        return np.dot(A, B) + np.dot(B, A)\n",
                "\n",
                "    for _ in range(steps):\n",
                "        k1 = 1j * commutator(H, C) + anticommutator(L, C) + M\n",
                "        k2 = 1j * commutator(H, C + 0.5 * k1 * delta_t) + anticommutator(L, C + 0.5 * k1 * delta_t) + M\n",
                "        k3 = 1j * commutator(H, C + 0.5 * k2 * delta_t) + anticommutator(L, C + 0.5 * k2 * delta_t) + M\n",
                "        k4 = 1j * commutator(H, C + k3 * delta_t) + anticommutator(L, C + k3 * delta_t) + M\n",
                "        C += (delta_t / 6) * (k1 + 2 * k2 + 2 * k3 + k4)\n",
                "\n",
                "    return np.diag(C).real"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "70250b9b",
            "metadata": {
                "id": "70250b9b"
            },
            "source": [
                "## Test Cases"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "id": "5da206f9",
            "metadata": {
                "id": "5da206f9"
            },
            "outputs": [],
            "source": [
                "# 32.3 - Test case 1\n",
                "n0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\n",
                "Gamma = 0.001\n",
                "P = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\n",
                "phi = np.pi / 2\n",
                "R = 0.99593306197 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-6\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "C0 = np.diag(n0)\n",
                "H = [\n",
                "    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n",
                "    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n",
                "    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n",
                "    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n",
                "    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n",
                "]\n",
                "L = - Gamma * np.identity(N) / 2\n",
                "M = 197.25 * Gamma * np.identity(N) / 2\n",
                "t0 = 0.02\n",
                "steps = 10000\n",
                "target = [ 6762435.17442855, 270122.3810029, 10004196.45838998, 19073172.61665625, 3440024.54245118 ]\n",
                "assert np.allclose(runge_kutta_dynamics(C0, H, L, M, t0, steps), target, rtol=1e-4, atol=1e-4)\n",
                "\n",
                "# 32.3 - Test case 2\n",
                "n0 = [197.25, 39549953.17, 39549953.17, 39549953.17, 39549953.17]\n",
                "Gamma = 0.001\n",
                "P = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\n",
                "phi = np.pi / 2\n",
                "R = 0.99593306197 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-6\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "C0 = np.diag(n0)\n",
                "H = [\n",
                "    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n",
                "    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n",
                "    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n",
                "    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n",
                "    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n",
                "]\n",
                "L = - Gamma * np.identity(N) / 2\n",
                "M = 197.25 * Gamma * np.identity(N) / 2\n",
                "t0 = 0.05\n",
                "steps = 10000\n",
                "target = [34044055.73846075, 36753347.53463306, 38766694.48731664, 36664745.76086929, 11963256.63062548]\n",
                "assert np.allclose(runge_kutta_dynamics(C0, H, L, M, t0, steps), target, rtol=1e-4, atol=1e-4)\n",
                "\n",
                "# 32.3 - Test case 3\n",
                "n0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\n",
                "Gamma = 0.001\n",
                "P = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\n",
                "phi = np.pi / 2\n",
                "R = 0.99593306197 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-6\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "C0 = np.diag(n0)\n",
                "H = [\n",
                "    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n",
                "    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n",
                "    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n",
                "    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n",
                "    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n",
                "]\n",
                "L = - Gamma * np.identity(N) / 2\n",
                "M = 197.25 * Gamma * np.identity(N) / 2\n",
                "t0 = 0.05\n",
                "steps = 50000\n",
                "target = [5504117.23331725, 2794825.43714492,  781478.48446118, 2883427.21090874, 27584916.3411524]\n",
                "assert np.allclose(runge_kutta_dynamics(C0, H, L, M, t0, steps), target, rtol=1e-4, atol=1e-4)\n",
                "\n",
                "# 32.3 - Test case 4\n",
                "n0 = [197.25, 197.25, 39549953.17, 197.25, 197.25]\n",
                "Gamma = 0\n",
                "P = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\n",
                "phi = np.pi / 2\n",
                "R = 0.99593306197 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-6\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "C0 = np.diag(n0)\n",
                "H = [\n",
                "    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n",
                "    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n",
                "    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n",
                "    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n",
                "    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n",
                "]\n",
                "L = - Gamma * np.identity(N) / 2\n",
                "M = 197.25 * Gamma * np.identity(N) / 2\n",
                "t0 = 0.02\n",
                "steps = 10000\n",
                "nf = runge_kutta_dynamics(C0, H, L, M, t0, steps)\n",
                "diff = sum(nf) - sum(n0)\n",
                "target = (np.True_, np.True_)\n",
                "def is_symmetric(array, rtol=1e-05, atol=1e-08):\n",
                "    return np.all(np.isclose(array, array[::-1], rtol=rtol, atol=atol))\n",
                "assert (abs(diff)<1e-6, is_symmetric(nf)) == target\n",
                "\n",
                "# 32.3 - Test case 5 - Different M coefficient, same step count range\n",
                "n0 = [39549953.17, 197.25, 197.25, 197.25, 197.25]\n",
                "Gamma = 0.001\n",
                "P = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]\n",
                "phi = np.pi / 2\n",
                "R = 0.99593306197 * 1550e-9\n",
                "l = 1550e-9\n",
                "w = 600e-9\n",
                "a = 100e-9\n",
                "n = 1.444\n",
                "h = 1e-6\n",
                "N = np.size(P)\n",
                "rho = 2.648e3\n",
                "C0 = np.diag(n0)\n",
                "H = [\n",
                "    [985147.05262796, 3519.91873466, 2026.13510524, 1382.4090176, 1042.19347808],\n",
                "    [3519.91873466, 982670.64171272, 3525.50675695, 2028.02156111, 1382.4090176 ],\n",
                "    [2026.13510524, 3525.50675695, 982026.55888623, 3525.50675695, 2026.13510524],\n",
                "    [1382.4090176, 2028.02156111, 3525.50675695, 982670.64171272, 3519.91873466],\n",
                "    [1042.19347808, 1382.4090176, 2026.13510524, 3519.91873466, 985147.05262796]\n",
                "]\n",
                "L = - Gamma * np.identity(N) / 2\n",
                "M = 500 * Gamma * np.identity(N) / 2\n",
                "t0 = 0.02\n",
                "steps = 10000\n",
                "target = [ 6762435.17442855, 270122.3810029, 10004196.45838998, 19073172.61665625, 3440024.54245118 ]\n",
                "output = runge_kutta_dynamics(C0, H, L, M, t0, steps)\n",
                "assert np.allclose(output, target, rtol=1e-4, atol=1e-4)"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "9a371313",
            "metadata": {
                "id": "9a371313"
            },
            "source": [
                "## Return Line"
            ]
        },
        {
            "cell_type": "markdown",
            "id": "2fb79c1a",
            "metadata": {
                "id": "2fb79c1a"
            },
            "source": []
        },
        {
            "cell_type": "markdown",
            "id": "a0786810",
            "metadata": {
                "id": "a0786810"
            },
            "source": [
                "# General Solution"
            ]
        },
        {
            "cell_type": "code",
            "source": [
                "import numpy as np\n",
                "from scipy.constants import epsilon_0, c\n",
                "from typing import List\n",
                "\n",
                "def calculate_binding_force(P: list[float], phi: float, R: float, l: float, w: float, a: float, n: float) -> float:\n",
                "    \"\"\"\n",
                "    Function to calculate the optical binding force between two trapped nanospheres.\n",
                "\n",
                "    Args:\n",
                "        P (list of float): Laser powers for the two nanospheres (Watts).\n",
                "        phi (float): Polarization angle of the tweezers (radians).\n",
                "        R (float): Distance between adjacent nanospheres (meters).\n",
                "        l (float): Wavelength of the optical tweezers (meters).\n",
                "        w (float): Beam waist of the optical tweezers (meters).\n",
                "        a (float): Radius of the nanospheres (meters).\n",
                "        n (float): Refractive index of the nanospheres.\n",
                "\n",
                "    Returns:\n",
                "        float: Optical binding force (Newtons).\n",
                "    \"\"\"\n",
                "    # Wave number\n",
                "    k = 2 * np.pi / l\n",
                "    # Scalar polarizability\n",
                "    alpha = (4 * np.pi * epsilon_0 * a**3 * (n**2 - 1)) / (n**2 + 2)\n",
                "    # Electric fields\n",
                "    E1 = np.sqrt(4 * P[0] / (np.pi * w**2 * epsilon_0 * c))\n",
                "    E2 = np.sqrt(4 * P[1] / (np.pi * w**2 * epsilon_0 * c))\n",
                "    # Forces\n",
                "    Fxx = (\n",
                "        2 * alpha**2 * E1 * E2 * np.cos(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n",
                "        * (-3 * np.cos(k * R) - 3 * k * R * np.sin(k * R) + (k * R)**2 * np.cos(k * R))\n",
                "    )\n",
                "    Fxy = (\n",
                "        alpha**2 * E1 * E2 * np.sin(phi)**2 / (8 * np.pi * epsilon_0 * R**4)\n",
                "        * (3 * np.cos(k * R) + 3 * k * R * np.sin(k * R) - 2 * (k * R)**2 * np.cos(k * R) - (k * R)**3 * np.sin(k * R))\n",
                "    )\n",
                "    return (Fxx + Fxy) * 1e12\n",
                "\n",
                "def generate_hamiltonian(P: list[float], phi: float, R: float, l: float, w: float, a: float,\n",
                "                         n: float, N: int, rho: float, k_ij: np.ndarray, gamma: np.ndarray) -> np.ndarray:\n",
                "    \"\"\"\n",
                "    Generate the Hamiltonian matrix for N nanospheres in an optical tweezer array.\n",
                "\n",
                "    Args:\n",
                "        P (list[float]): List of laser powers for each nanosphere (Watts)\n",
                "        phi (float): Polarization angle (radians)\n",
                "        R (float): Distance between adjacent nanospheres (meters)\n",
                "        l (float): Wavelength of optical tweezers (meters)\n",
                "        w (float): Beam waist of optical tweezers (meters)\n",
                "        a (float): Radius of nanospheres (meters)\n",
                "        n (float): Refractive index of nanospheres\n",
                "        N (int): Number of nanospheres\n",
                "        rho (float): Density of nanospheres (kg/m\u00b3)\n",
                "        k_ij (np.ndarray): Pairwise binding forces (N)\n",
                "        gamma (np.ndarray): Damping coefficients for each nanosphere\n",
                "\n",
                "    Returns:\n",
                "        np.ndarray: NxN Hamiltonian matrix\n",
                "    \"\"\"\n",
                "    # Mass, polarizability, initial k_i\n",
                "    m: float = (4/3) * np.pi * (a**3) * rho\n",
                "    alpha: float = 4 * np.pi * epsilon_0 * a**3 * ((n**2 - 1)/(n**2 + 2))\n",
                "    k_i: np.ndarray = np.array([(8 * alpha * p)/(np.pi * w**4 * epsilon_0 * c) for p in P])\n",
                "\n",
                "    # Resonant frequencies\n",
                "    Omega: np.ndarray = np.zeros(N)\n",
                "    for i in range(N):\n",
                "        k_eff = k_i[i] + gamma[i] + np.sum(k_ij[i, :])\n",
                "        if k_eff < 0:\n",
                "            print(f\"Warning: Negative effective spring constant for particle {i}. Clamping to zero.\")\n",
                "            k_eff = 0\n",
                "        Omega[i] = np.sqrt(k_eff / m) if k_eff > 0 else 0\n",
                "\n",
                "    # Hamiltonian matrix\n",
                "    H: np.ndarray = np.zeros((N, N))\n",
                "    np.fill_diagonal(H, Omega)\n",
                "    for i in range(N):\n",
                "        for j in range(i + 1, N):\n",
                "            if Omega[i] > 0 and Omega[j] > 0:\n",
                "                g_ij: float = -k_ij[i, j] / (2 * m * np.sqrt(Omega[i] * Omega[j]))\n",
                "                H[i, j] = H[j, i] = g_ij\n",
                "    return H\n",
                "\n",
                "def runge_kutta_dynamics(C0: np.ndarray, H: np.ndarray, L: np.ndarray, M: np.ndarray, t0: float, steps: int) -> np.ndarray:\n",
                "    \"\"\"\n",
                "    Simulates the evolution of the correlation matrix for a system of coupled nanospheres using the fourth-order Runge-Kutta (RK4) method.\n",
                "\n",
                "    Args:\n",
                "        C0 (numpy.ndarray): Initial correlation matrix (complex Hermitian).\n",
                "        H (numpy.ndarray): Hamiltonian matrix (real symmetric).\n",
                "        L (numpy.ndarray): Dissipation matrix (real diagonal).\n",
                "        M (numpy.ndarray): Reservoir matrix (real diagonal).\n",
                "        t0 (float): Total simulation time (seconds).\n",
                "        steps (int): Number of RK4 time steps.\n",
                "\n",
                "    Returns:\n",
                "        numpy.ndarray: Diagonal elements of the final correlation matrix representing phonon occupations.\n",
                "    \"\"\"\n",
                "    delta_t = t0 / steps\n",
                "    C = np.array(C0, dtype=np.complex128)\n",
                "\n",
                "    def commutator(A, B) -> np.ndarray:\n",
                "        return np.dot(A, B) - np.dot(B, A)\n",
                "\n",
                "    def anticommutator(A, B) -> np.ndarray:\n",
                "        return np.dot(A, B) + np.dot(B, A)\n",
                "\n",
                "    for _ in range(steps):\n",
                "        k1 = 1j * commutator(H, C) + anticommutator(L, C) + M\n",
                "        k2 = 1j * commutator(H, C + 0.5 * k1 * delta_t) + anticommutator(L, C + 0.5 * k1 * delta_t) + M\n",
                "        k3 = 1j * commutator(H, C + 0.5 * k2 * delta_t) + anticommutator(L, C + 0.5 * k2 * delta_t) + M\n",
                "        k4 = 1j * commutator(H, C + k3 * delta_t) + anticommutator(L, C + k3 * delta_t) + M\n",
                "        C += (delta_t / 6) * (k1 + 2 * k2 + 2 * k3 + k4)\n",
                "\n",
                "    return np.diag(C).real\n",
                "def solve_multiparticle_dynamics(N: int, t0: float, R: float, l: float, phi: float, Gamma: float, P: list[float], n0: list[float], w: float, a: float, n: float, h: float, rho: float, steps: int, L: np.ndarray = None, M: np.ndarray = None, gamma: np.ndarray = None) -> list[float]:\n",
                "\n",
                "    \"\"\"\n",
                "    Simulates phonon occupation dynamics in an optical tweezer array.\n",
                "\n",
                "    Args:\n",
                "        N (int): Number of nanospheres.\n",
                "        t0 (float): Time for simulation (seconds).\n",
                "        R (float): Distance between adjacent nanospheres (meters).\n",
                "        l (float): Wavelength of optical tweezers (meters).\n",
                "        phi (float): Polarization angle (radians).\n",
                "        Gamma (float): Damping coefficient for nanospheres.\n",
                "        P (list): Powers of optical tweezers (Watts).\n",
                "        n0 (list): Initial phonon occupation numbers.\n",
                "        w (float): Beam waist of optical tweezers (meters).\n",
                "        a (float): Radius of nanospheres (meters).\n",
                "        n (float): Refractive index of the nanospheres.\n",
                "        h (float): Step size for numerical derivative (meters).\n",
                "        rho (float): Density of nanospheres (kg/m\u00b3).\n",
                "        steps (int): Number of RK4 time steps.\n",
                "        L (np.ndarray, optional): Coupling matrix for the nanospheres.\n",
                "        M (np.ndarray, optional): Mass matrix for the nanospheres.\n",
                "        gamma (np.ndarray, optional): Interaction strength matrix for the system, representing additional inter-particle effects.\n",
                "\n",
                "    Returns:\n",
                "        list: Phonon occupation numbers at time t0.\n",
                "    \"\"\"\n",
                "\n",
                "    k_ij = np.zeros((N, N))\n",
                "    for i in range(N):\n",
                "        for j in range(i + 1, N):\n",
                "            R_ij = abs(i - j) * R\n",
                "            F_plus = calculate_binding_force([P[i], P[j]], phi, R_ij + h, l, w, a, n)\n",
                "            F_minus = calculate_binding_force([P[i], P[j]], phi, R_ij - h, l, w, a, n)\n",
                "            k_ij[i, j] = k_ij[j, i] = max((F_plus - F_minus) / (2 * h), 0)\n",
                "\n",
                "    # Initialize gamma if not provided\n",
                "    if gamma is None:\n",
                "        gamma = Gamma * np.ones(N)\n",
                "\n",
                "    # Generate Hamiltonian\n",
                "    H = generate_hamiltonian(P, phi, R, l, w, a, n, N, rho, k_ij, gamma)\n",
                "\n",
                "    # Initial correlation matrix\n",
                "    C0 = np.diag(n0)\n",
                "\n",
                "    # Default dissipation and reservoir matrices\n",
                "    if L is None:\n",
                "        L = -Gamma * np.identity(N) / 2\n",
                "    if M is None:\n",
                "        M = Gamma * np.identity(N) / 2\n",
                "\n",
                "    # Run dynamics\n",
                "    nf = runge_kutta_dynamics(C0, H, L, M, t0, steps)\n",
                "    return nf.tolist()\n"
            ],
            "metadata": {
                "id": "Xz2_5XIjFTf4"
            },
            "id": "Xz2_5XIjFTf4",
            "execution_count": 231,
            "outputs": []
        },
        {
            "cell_type": "code",
            "source": [
                "# General test case 1\n",
                "n0 = [500, 400, 300, 200, 100]  # Initial phonon occupation numbers\n",
                "Gamma = 0.05  # Lower damping coefficient\n",
                "P = [50e-3, 50e-3, 50e-3, 50e-3, 50e-3]  # Laser powers for each nanosphere (Watts)\n",
                "phi = np.pi / 3  # Polarization angle (radians)\n",
                "R = 1.2e-6  # Distance between adjacent nanospheres (meters)\n",
                "l = 1.5e-7  # Wavelength of optical tweezers (meters)\n",
                "w = 4e-7  # Beam waist (meters)\n",
                "a = 60e-9  # Radius of nanospheres (meters)\n",
                "n = 1.55  # Refractive index of nanospheres\n",
                "h = 1e-8  # Step size for numerical derivative (meters)\n",
                "N = len(P)  # Number of nanospheres\n",
                "rho = 2.5e3  # Density of nanospheres (kg/m\u00b3)\n",
                "t0 = 2.0  # Longer simulation time (seconds)\n",
                "steps = 500  # Increased number of RK4 steps for finer resolution\n",
                "\n",
                "# Gamma values for each nanosphere\n",
                "gamma = np.array([0.05, 0.05, 0.05, 0.05, 0.05])  # Example external spring constants\n",
                "\n",
                "# Expected target values\n",
                "target = [655, 529, 403, 277, 151]\n",
                "\n",
                "# Compute the output\n",
                "output = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps, gamma)\n",
                "\n",
                "# Assert the result matches the target within tolerance\n",
                "assert np.allclose(output, target, rtol=1e-1), f\"Output {output} does not match target {target}\"\n",
                "\n",
                "# General test case 2\n",
                "n0 = [1000, 800, 600, 400, 200]  # Initial phonon occupation numbers\n",
                "Gamma = 0.02  # Damping coefficient\n",
                "P = [75e-3, 75e-3, 75e-3, 75e-3, 75e-3]  # Laser powers for each nanosphere (Watts)\n",
                "phi = np.pi / 4  # Polarization angle (radians)\n",
                "R = 1.5e-6  # Distance between adjacent nanospheres (meters)\n",
                "l = 1.0e-7  # Wavelength of optical tweezers (meters)\n",
                "w = 3.5e-7  # Beam waist (meters)\n",
                "a = 70e-9  # Radius of nanospheres (meters)\n",
                "n = 1.6  # Refractive index of nanospheres\n",
                "h = 2e-8  # Step size for numerical derivative (meters)\n",
                "N = len(P)  # Number of nanospheres\n",
                "rho = 2.0e3  # Density of nanospheres (kg/m\u00b3)\n",
                "t0 = 1.5  # Simulation time (seconds)\n",
                "steps = 500  # Number of RK4 steps for finer resolution\n",
                "\n",
                "# Gamma values for each nanosphere\n",
                "gamma = np.array([0.02, 0.02, 0.02, 0.02, 0.02])\n",
                "\n",
                "# Expected target values\n",
                "target = [1068, 855, 642, 429, 216]\n",
                "\n",
                "# Compute the output\n",
                "output = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps, gamma)\n",
                "\n",
                "# Assert the result matches the target within tolerance\n",
                "assert np.allclose(output, target, rtol=1e-3), f\"Output {output} does not match target {target}\"\n",
                "\n",
                "# General test case 3: Low damping and high laser power\n",
                "n0 = [300, 250, 200, 150, 100]  # Initial phonon occupation numbers\n",
                "Gamma = 0.01  # Very low damping coefficient\n",
                "P = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]  # High laser powers for each nanosphere (Watts)\n",
                "phi = np.pi / 6  # Polarization angle (radians)\n",
                "R = 1.0e-6  # Distance between adjacent nanospheres (meters)\n",
                "l = 2.0e-7  # Wavelength of optical tweezers (meters)\n",
                "w = 5e-7  # Beam waist (meters)\n",
                "a = 50e-9  # Radius of nanospheres (meters)\n",
                "n = 1.8  # Refractive index of nanospheres\n",
                "h = 5e-9  # Smaller step size for numerical derivative (meters)\n",
                "N = len(P)  # Number of nanospheres\n",
                "rho = 1.5e3  # Density of nanospheres (kg/m\u00b3)\n",
                "t0 = 3.0  # Longer simulation time (seconds)\n",
                "steps = 1000  # Increased number of RK4 steps for very fine resolution\n",
                "\n",
                "# Gamma values for each nanosphere\n",
                "gamma = np.array([0.01, 0.01, 0.01, 0.01, 0.01])  # Uniform external spring constants\n",
                "\n",
                "# Expected target values\n",
                "target = [320, 267, 214, 160, 107]\n",
                "\n",
                "# Compute the output\n",
                "output = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps, gamma)\n",
                "\n",
                "# Assert the result matches the target within tolerance\n",
                "assert np.allclose(output, target, rtol=1e-1), f\"Output {output} does not match target {target}\"\n",
                "\n",
                "# General test case 4: Extreme initial phonon occupation with small damping\n",
                "n0 = [39549953.17, 200.0, 200.0, 200.0, 200.0]  # Extreme phonon occupation for the first nanosphere\n",
                "Gamma = 0.001  # Very low damping coefficient\n",
                "P = [100e-3, 100e-3, 100e-3, 100e-3, 100e-3]  # Uniform laser powers for each nanosphere (Watts)\n",
                "phi = np.pi / 2  # Polarization angle (radians)\n",
                "R = 0.99593306197 * 1550e-9  # Distance between adjacent nanospheres (meters)\n",
                "l = 1550e-9  # Wavelength of optical tweezers (meters)\n",
                "w = 600e-9  # Beam waist (meters)\n",
                "a = 100e-9  # Radius of nanospheres (meters)\n",
                "n = 1.444  # Refractive index of nanospheres\n",
                "h = 1e-8  # Small step size for numerical derivative (meters)\n",
                "N = np.size(P)  # Number of nanospheres\n",
                "rho = 2.648e3  # Density of nanospheres (kg/m\u00b3)\n",
                "t0 = 0.02  # Short simulation time (seconds)\n",
                "steps = 10000  # High resolution with a large number of RK4 steps\n",
                "\n",
                "# Gamma values for each nanosphere\n",
                "gamma = np.array([0.001, 0.001, 0.001, 0.001, 0.001])  # Uniform low external spring constants\n",
                "\n",
                "# Expected target values\n",
                "target = [39551535, 200, 200, 200, 200]\n",
                "\n",
                "# Compute the output\n",
                "output = solve_multiparticle_dynamics(N, t0, R, l, phi, Gamma, P, n0, w, a, n, h, rho, steps, gamma)\n",
                "\n",
                "# Assert the result matches the target within tolerance\n",
                "assert np.allclose(output, target, rtol=1e-1), f\"Output {output} does not match target {target}\"\n",
                "\n"
            ],
            "metadata": {
                "id": "C9Mpps8jHr_3"
            },
            "id": "C9Mpps8jHr_3",
            "execution_count": 232,
            "outputs": []
        },
        {
            "cell_type": "code",
            "source": [],
            "metadata": {
                "id": "Wm85tWtFVBCn"
            },
            "id": "Wm85tWtFVBCn",
            "execution_count": null,
            "outputs": []
        }
    ],
    "metadata": {
        "colab": {
            "provenance": []
        },
        "language_info": {
            "name": "python"
        },
        "kernelspec": {
            "name": "python3",
            "display_name": "Python 3"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 5
}